import type { Edge, Node } from 'reactflow'
import type { FlowNodeData } from './types'

type GraphSnapshot = {
  nodes: Node<FlowNodeData>[]
  edges: Edge[]
}

const toSnake = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')

const toCamel = (value: string) => {
  const parts = value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .split(/\s+/)
  const [first, ...rest] = parts
  return [first ?? 'node', ...rest.map((word) => word[0].toUpperCase() + word.slice(1))].join('')
}

const buildNodeNames = (nodes: Node<FlowNodeData>[]) => {
  const names = new Map<string, { key: string; fn: string }>()
  const used = new Set<string>()

  nodes.forEach((node, index) => {
    const base = toSnake(node.data.label) || `${node.data.kind}_${index + 1}`
    let key = base
    let counter = 1
    while (used.has(key)) {
      counter += 1
      key = `${base}_${counter}`
    }
    used.add(key)
    names.set(node.id, { key, fn: `${key}_node` })
  })

  return names
}

export const generateLangGraphPython = ({ nodes, edges }: GraphSnapshot) => {
  const names = buildNodeNames(nodes)
  const lines: string[] = []

  lines.push('# Generated by GraphBuilder')
  lines.push('from typing import TypedDict')
  lines.push('from langgraph.graph import StateGraph, START, END')
  lines.push('')
  lines.push('class State(TypedDict):')
  lines.push('    input: str')
  lines.push('    output: str')
  lines.push('')

  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    lines.push(`def ${name.fn}(state: State) -> dict:`)
    lines.push(`    """${node.data.label || 'Untitled node'}: ${node.data.description}"""`)
    if (node.data.tools.length > 0) {
      lines.push(`    # Tools: ${node.data.tools.join(', ')}`)
    }
    if (node.data.kind === 'router') {
      lines.push('    # TODO: return the next node key based on state')
      lines.push('    return {"route": ""}')
    } else {
      lines.push('    # TODO: implement node behavior')
      lines.push('    return {}')
    }
    lines.push('')
  })

  lines.push('graph = StateGraph(State)')
  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    lines.push(`graph.add_node("${name.key}", ${name.fn})`)
  })
  lines.push('')

  const startNode = nodes[0]
  if (startNode) {
    const startName = names.get(startNode.id)
    if (startName) {
      lines.push(`graph.add_edge(START, "${startName.key}")`)
    }
  }

  edges.forEach((edge) => {
    const source = names.get(edge.source)
    const target = names.get(edge.target)
    if (!source || !target) return
    lines.push(`graph.add_edge("${source.key}", "${target.key}")`)
  })

  if (startNode) {
    const lastNode = nodes[nodes.length - 1]
    const lastName = lastNode ? names.get(lastNode.id) : undefined
    if (lastName) {
      lines.push(`graph.add_edge("${lastName.key}", END)`)
    }
  }

  lines.push('')
  lines.push('app = graph.compile()')
  lines.push('# app.invoke({"input": "..."})')

  return lines.join('\n')
}

export const generateLangGraphTS = ({ nodes, edges }: GraphSnapshot) => {
  const names = buildNodeNames(nodes)
  const lines: string[] = []

  lines.push('// Generated by GraphBuilder')
  lines.push('import { Annotation, StateGraph, START, END } from "@langchain/langgraph";')
  lines.push('')
  lines.push('const State = Annotation.Root({')
  lines.push('  input: Annotation<string>(),')
  lines.push('  output: Annotation<string>(),')
  lines.push('});')
  lines.push('')

  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    const fnName = toCamel(name.fn)
    lines.push(`const ${fnName} = async (state: typeof State.State) => {`)
    lines.push(`  // ${node.data.label || 'Untitled node'}: ${node.data.description}`)
    if (node.data.tools.length > 0) {
      lines.push(`  // Tools: ${node.data.tools.join(', ')}`)
    }
    if (node.data.kind === 'router') {
      lines.push('  // TODO: return the next node key based on state')
      lines.push('  return { route: "" };')
    } else {
      lines.push('  // TODO: implement node behavior')
      lines.push('  return {};')
    }
    lines.push('};')
    lines.push('')
  })

  lines.push('const graph = new StateGraph(State);')
  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    const fnName = toCamel(name.fn)
    lines.push(`graph.addNode("${name.key}", ${fnName});`)
  })
  lines.push('')

  const startNode = nodes[0]
  if (startNode) {
    const startName = names.get(startNode.id)
    if (startName) {
      lines.push(`graph.addEdge(START, "${startName.key}");`)
    }
  }

  edges.forEach((edge) => {
    const source = names.get(edge.source)
    const target = names.get(edge.target)
    if (!source || !target) return
    lines.push(`graph.addEdge("${source.key}", "${target.key}");`)
  })

  if (startNode) {
    const lastNode = nodes[nodes.length - 1]
    const lastName = lastNode ? names.get(lastNode.id) : undefined
    if (lastName) {
      lines.push(`graph.addEdge("${lastName.key}", END);`)
    }
  }

  lines.push('')
  lines.push('const app = graph.compile();')
  lines.push('// await app.invoke({ input: "..." });')

  return lines.join('\n')
}
