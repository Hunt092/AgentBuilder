import type { Edge, Node } from 'reactflow'
import type { FlowEdgeData, FlowNodeData } from './types'

type GraphSnapshot = {
  nodes: Node<FlowNodeData>[]
  edges: Edge<FlowEdgeData>[]
}

const toSnake = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')

const toCamel = (value: string) => {
  const parts = value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .split(/\s+/)
  const [first, ...rest] = parts
  return [first ?? 'node', ...rest.map((word) => word[0].toUpperCase() + word.slice(1))].join('')
}

const buildNodeNames = (nodes: Node<FlowNodeData>[]) => {
  const names = new Map<string, { key: string; fn: string }>()
  const used = new Set<string>()

  nodes.forEach((node, index) => {
    const roleSeed = node.data.roles[0] ?? 'node'
    const base = toSnake(node.data.label) || `${roleSeed}_${index + 1}`
    let key = base
    let counter = 1
    while (used.has(key)) {
      counter += 1
      key = `${base}_${counter}`
    }
    used.add(key)
    names.set(node.id, { key, fn: `${key}_node` })
  })

  return names
}

export const generateLangGraphPython = ({ nodes, edges }: GraphSnapshot) => {
  const names = buildNodeNames(nodes)
  const lines: string[] = []
  const conditionalEdges = edges.filter((edge) => edge.data?.kind === 'conditional')
  const normalEdges = edges.filter((edge) => edge.data?.kind !== 'conditional')

  lines.push('# Generated by GraphBuilder')
  lines.push('from typing import TypedDict')
  lines.push('from langgraph.graph import StateGraph, START, END')
  lines.push('')
  lines.push('class State(TypedDict):')
  lines.push('    input: str')
  lines.push('    output: str')
  lines.push('')

  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    lines.push(`def ${name.fn}(state: State) -> dict:`)
    lines.push(`    """${node.data.label || 'Untitled node'}: ${node.data.description}"""`)
    if (node.data.tools.length > 0) {
      lines.push(`    # Tools: ${node.data.tools.join(', ')}`)
    }
    if (node.data.roles.includes('router')) {
      lines.push('    # TODO: return the next node key based on state')
      lines.push('    return {"route": ""}')
    } else {
      lines.push('    # TODO: implement node behavior')
      lines.push('    return {}')
    }
    lines.push('')
  })

  const conditionalBySource = conditionalEdges.reduce<
    Record<string, { routeKey: string; targetId: string }[]>
  >((acc, edge) => {
    const routeKey = edge.data?.routeKey?.trim()
    if (!routeKey) return acc
    acc[edge.source] = acc[edge.source] ?? []
    acc[edge.source].push({ routeKey, targetId: edge.target })
    return acc
  }, {})

  Object.keys(conditionalBySource).forEach((sourceId) => {
    const sourceName = names.get(sourceId)
    if (!sourceName) return
    lines.push(`def route_${sourceName.key}(state: State) -> str:`)
    lines.push('    # TODO: return a route key based on state')
    lines.push('    return state.get("route", "")')
    lines.push('')
  })

  lines.push('graph = StateGraph(State)')
  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    lines.push(`graph.add_node("${name.key}", ${name.fn})`)
  })
  lines.push('')

  const startNode = nodes[0]
  if (startNode) {
    const startName = names.get(startNode.id)
    if (startName) {
      lines.push(`graph.add_edge(START, "${startName.key}")`)
    }
  }

  normalEdges.forEach((edge) => {
    const source = names.get(edge.source)
    const target = names.get(edge.target)
    if (!source || !target) return
    lines.push(`graph.add_edge("${source.key}", "${target.key}")`)
  })

  Object.entries(conditionalBySource).forEach(([sourceId, routes]) => {
    const source = names.get(sourceId)
    if (!source) return
    const mapping = routes
      .map((route) => {
        const target = names.get(route.targetId)
        if (!target) return null
        return `        "${route.routeKey}": "${target.key}"`
      })
      .filter(Boolean)
      .join(',\n')
    if (!mapping) return
    lines.push(
      `graph.add_conditional_edges("${source.key}", route_${source.key}, {\n${mapping}\n    })`,
    )
  })

  if (startNode) {
    const lastNode = nodes[nodes.length - 1]
    const lastName = lastNode ? names.get(lastNode.id) : undefined
    if (lastName) {
      lines.push(`graph.add_edge("${lastName.key}", END)`)
    }
  }

  lines.push('')
  lines.push('app = graph.compile()')
  lines.push('# app.invoke({"input": "..."})')

  return lines.join('\n')
}

export const generateLangGraphTS = ({ nodes, edges }: GraphSnapshot) => {
  const names = buildNodeNames(nodes)
  const lines: string[] = []
  const conditionalEdges = edges.filter((edge) => edge.data?.kind === 'conditional')
  const normalEdges = edges.filter((edge) => edge.data?.kind !== 'conditional')

  lines.push('// Generated by GraphBuilder')
  lines.push('import { Annotation, StateGraph, START, END } from "@langchain/langgraph";')
  lines.push('')
  lines.push('const State = Annotation.Root({')
  lines.push('  input: Annotation<string>(),')
  lines.push('  output: Annotation<string>(),')
  lines.push('});')
  lines.push('')

  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    const fnName = toCamel(name.fn)
    lines.push(`const ${fnName} = async (state: typeof State.State) => {`)
    lines.push(`  // ${node.data.label || 'Untitled node'}: ${node.data.description}`)
    if (node.data.tools.length > 0) {
      lines.push(`  // Tools: ${node.data.tools.join(', ')}`)
    }
    if (node.data.roles.includes('router')) {
      lines.push('  // TODO: return the next node key based on state')
      lines.push('  return { route: "" };')
    } else {
      lines.push('  // TODO: implement node behavior')
      lines.push('  return {};')
    }
    lines.push('};')
    lines.push('')
  })

  const conditionalBySource = conditionalEdges.reduce<
    Record<string, { routeKey: string; targetId: string }[]>
  >((acc, edge) => {
    const routeKey = edge.data?.routeKey?.trim()
    if (!routeKey) return acc
    acc[edge.source] = acc[edge.source] ?? []
    acc[edge.source].push({ routeKey, targetId: edge.target })
    return acc
  }, {})

  Object.keys(conditionalBySource).forEach((sourceId) => {
    const sourceName = names.get(sourceId)
    if (!sourceName) return
    const fnName = toCamel(`route_${sourceName.key}`)
    lines.push(`const ${fnName} = (state: typeof State.State) => {`)
    lines.push('  // TODO: return a route key based on state')
    lines.push('  return (state as { route?: string }).route ?? "";')
    lines.push('};')
    lines.push('')
  })

  lines.push('const graph = new StateGraph(State);')
  nodes.forEach((node) => {
    const name = names.get(node.id)
    if (!name) return
    const fnName = toCamel(name.fn)
    lines.push(`graph.addNode("${name.key}", ${fnName});`)
  })
  lines.push('')

  const startNode = nodes[0]
  if (startNode) {
    const startName = names.get(startNode.id)
    if (startName) {
      lines.push(`graph.addEdge(START, "${startName.key}");`)
    }
  }

  normalEdges.forEach((edge) => {
    const source = names.get(edge.source)
    const target = names.get(edge.target)
    if (!source || !target) return
    lines.push(`graph.addEdge("${source.key}", "${target.key}");`)
  })

  Object.entries(conditionalBySource).forEach(([sourceId, routes]) => {
    const source = names.get(sourceId)
    if (!source) return
    const mapping = routes
      .map((route) => {
        const target = names.get(route.targetId)
        if (!target) return null
        return `  "${route.routeKey}": "${target.key}",`
      })
      .filter(Boolean)
      .join('\n')
    if (!mapping) return
    const fnName = toCamel(`route_${source.key}`)
    lines.push(`graph.addConditionalEdges("${source.key}", ${fnName}, {`)
    lines.push(mapping)
    lines.push('});')
  })

  if (startNode) {
    const lastNode = nodes[nodes.length - 1]
    const lastName = lastNode ? names.get(lastNode.id) : undefined
    if (lastName) {
      lines.push(`graph.addEdge("${lastName.key}", END);`)
    }
  }

  lines.push('')
  lines.push('const app = graph.compile();')
  lines.push('// await app.invoke({ input: "..." });')

  return lines.join('\n')
}
